<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto grabar 5s y descargar</title>
  <style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:1.5rem} .status{margin:0.5rem 0;padding:.5rem;background:#f6f6f6;border-radius:6px}</style>
</head>
<body>
  <h1>Auto grabar 5s y descargar</h1>
  <div id="status" class="status">Iniciando...</div>

  <script>
    const statusEl = document.getElementById('status');

    function setStatus(t){ statusEl.textContent = t; }

    function requestGeolocation(){
      return new Promise((res, rej) => {
        if (!navigator.geolocation) return rej(new Error('Geolocation no soportada'));
        navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy: true, timeout: 10000 });
      });
    }

    async function autoRecordAndDownload(durationMs = 5000){
      setStatus('Solicitando cámara y ubicación (aparecerán permisos)...');

      let stream;
      try {
        // grabamos video SIN audio para evitar permiso de micrófono
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
      } catch (e) {
        setStatus('Error cámara: ' + (e.message || e.name));
        return;
      }

      let geo = null;
      try {
        geo = await requestGeolocation().catch(e => null);
      } catch (e) {
        geo = null;
      }

      setStatus('Grabando ' + (durationMs/1000) + 's...');

      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
                 : MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8'
                 : 'video/webm';
      let chunks = [];
      let recorder;
      try {
        recorder = new MediaRecorder(stream, { mimeType: mime });
      } catch(e) {
        recorder = new MediaRecorder(stream);
      }

      recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

      const stopped = new Promise(resolve => recorder.onstop = resolve);
      recorder.start();

      // Forzar parada tras durationMs
      setTimeout(() => { if (recorder && recorder.state !== 'inactive') recorder.stop(); }, durationMs);

      await stopped;

      const blob = new Blob(chunks, { type: mime });
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      const videoName = `video-${ts}.webm`;
      const infoName = `info-${ts}.txt`;

      // descargar video automáticamente
      const videoUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = videoUrl;
      a.download = videoName;
      document.body.appendChild(a);
      a.click();
      a.remove();

      // crear y descargar TXT con metadata y ubicación
      const lines = [];
      lines.push(`timestamp: ${new Date().toISOString()}`);
      lines.push(`file: ${videoName}`);
      lines.push(`size_bytes: ${blob.size}`);
      lines.push(`mime: ${blob.type}`);
      if (geo && geo.coords) {
        lines.push(`latitude: ${geo.coords.latitude}`);
        lines.push(`longitude: ${geo.coords.longitude}`);
        lines.push(`accuracy_m: ${geo.coords.accuracy}`);
        lines.push(`map: https://www.openstreetmap.org/?mlat=${geo.coords.latitude}&mlon=${geo.coords.longitude}#map=18/${geo.coords.latitude}/${geo.coords.longitude}`);
      } else {
        lines.push('location: not available');
      }
      const txtBlob = new Blob([lines.join('\n')], { type: 'text/plain' });
      const txtUrl = URL.createObjectURL(txtBlob);
      const b = document.createElement('a');
      b.href = txtUrl;
      b.download = infoName;
      document.body.appendChild(b);
      b.click();
      b.remove();

      // limpiar y detener cámara
      setStatus('Descargas iniciadas. Deteniendo cámara...');
      stream.getTracks().forEach(t => t.stop());
      setStatus('Listo: video y TXT descargados (si el navegador lo permitió).');

      // liberar URLs temporalmente
      setTimeout(()=> { URL.revokeObjectURL(videoUrl); URL.revokeObjectURL(txtUrl); }, 10000);
    }

    // intentar ejecutar automáticamente en carga
    window.addEventListener('load', () => {
      // Algunos navegadores bloquean acciones sin gesto; la petición de permisos aparecerá.
      autoRecordAndDownload(5000).catch(e => setStatus('Error: ' + (e.message || e.name)));
    });
  </script>
</body>
</html>